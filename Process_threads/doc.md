# 进程与线程

## 进程
### 进程相关概念
 - 并行和并发 
 - `PCB`：PCB - 进程控制块（Processing Control Block）
 - 进程状态
   ```c
   //linux源码定义进程状态如下
    static const char * const task_state_array[] = {
    "R (running)", /* 0 */   -运行或将要运行
    "S (sleeping)", /* 1 */  -进程在等待事件完成
    "D (disk sleep)", /* 2 */ -此状态进程通常等待IO结束
    "T (stopped)", /* 4 */   -停止状态
    "t (tracing stop)", /* 8 */ -追踪中
    "X (dead)", /* 16 */  -死亡状态
    "Z (zombie)", /* 32 */ -僵尸进程
    };
   ```
 - 进程优先级：CPU分配资源的先后顺序就是进程的优先级
   - `PRI`:代表这个进程执行的优先级，其值越小越早被执行
   - `NI`:代表这个进程的NICE值，用于修正进程优先级
 - 创建进程 - fork
    - 父进程使用`fork`创建子进程，返回值为子进程的`id`
    - 子进程调用`fork`,返回值为 `0`
 - 父子进程
    - 代码共享，数据私有
 - `exec`族函数
    - 通过一个进程启动另一个进程，这种情况下我们可以使用`exec`族函数
    ![](../image/1.png)
 - 进程控制
    - 结束进程：调用`exit(n)`函数，`n`即为进程结束后的返回值，`0`代表进程正常退出
    - 孤儿进程
      - 父进程先挂，子进程还继续运行，此时子进程会被1号进程领养，1号进程即为`systemd`
    - 僵尸进程
      - 子进程直接结束，没有告诉父进程自己挂了，所以子进程结束时一定要给父进程一个结束码
    - 进程回收
### 进程相关命令
```shell
 ps aux  #列出所有进程
	- a: 查看所有终端的信息
	- u: 查看用户相关的信息
	- x: 显示和终端无关的进程信息
 ps axj #查看父子进程关系
 ps aux | grep 文件名称/进程名字
 ps -l 列出当前用户创建的进程
```

## 线程
线程是轻量级的进程（LWP：light weight process），在 Linux 环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，**进程是资源分配的最小单位，线程是操作系统调度执行的最小单位**。

 - 进程有自己独立的地址空间，多个线程共用同一个地址空间
   - 线程更加节省系统资源，效率不仅可以保持的，而且能够更高
   - 在一个地址空间中多个线程独享：每个线程都有属于自己的栈区，寄存器 (内核中管理的)
   - 在一个地址空间中多个线程共享：代码段，堆区，全局数据区，打开的文件 (文件描述符表) 都是线程共享的
 - 线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位
   - 每个进程对应一个虚拟地址空间，一个进程只能抢一个 CPU 时间片
一个地址空间中可以划分出多个线程，在有效的资源基础上，能够抢更多的 CPU 时间片   

![](../image/2.png)


### 多线程编程
 - **POSIX 线程库**   
 在Linux中是用进程模拟线程的，所以就不会用形如 `fork()` 这类的系统调用提供给我们用来专门控制线程。所以要实现多线程，就要使用到库函数，这里面比较底层的是`POSIX`线程库，所以它就是产生的就是用户级别的线程，其绝大多数函数名字都是以 `pthread_` 开头，并且注意引入头文件`<pthread.h>`，而且链接时注意加入 `-1pthread` 选项
 - **创建线程-pthread_create**
 - **线程终止-pthread_exit**
 - **线程等待-pthread_join**
 - **线程分离-pthread_detach**      
 主线程在阻塞等待时不能处理自己的任务，可以采用线程分离让子线程在结束后自己释放资源
  